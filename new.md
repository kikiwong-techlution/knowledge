### 参考来源https://github.com/mqyqingfeng/Blog

#### 从原型到原型链  
- `prototype`  
每一个函数都有一个`prototype`属性。函数的`prototype`属性指向了一个对象，该对象是调用该构造函数而创建的实例的原型。每个对象都会从原型“继承”属性。
- `__proto__`  
每个JavaScript对象都会有一个属性，叫`__proto__`，这个属性会指向该对象的原型。
    ```javascript
    function Person(){}
    var person = new Person()
    person.__proto__ === Person.prototype;  //true
    ```
- `constructor`  
每个原型都会有一个`constructor`属性指向关联的构造函数
    ```javascript
    function Person(){}
    var person = new Person()
    Person === Person.prototype.constructor;  //true
    ```
- 实例与原型  
当读取实例的属性时，如果找不到，就会查找与对象关联的原型中属性；如果还找不到，就去找原型的原型，一直到最顶层为止。  
原型的原型是`Object.prototype`,原型对象是通过`Object`构造函数生成的。  
`Object.prototype`没有原型，会指向null。
- 原型链  
相互关联的原型组成的链状结构就是原型链

#### 词法作用域和动态作用域  
作用域是指程序源代码中定义变量的区域。
作用域是一套规则，用于确定在何处以及如何查找变量（标识符），即确定当前执行代码对变量的访问权限。  
作用域两种主要的工作模式：  
- 词法作用域（lexical scoping）：函数的作用域在函数定义的时候就决定了
- 动态作用域：函数的作用域在函数调用的时候才决定的   

JavaScript采用的是词法作用域，即静态作用域。

#### 执行上下文栈  
在JS中的执行顺序，是一段一段的分析和执行，当执行一段代码时，会进行一个“准备工作”，比如变量提升、函数提升。  
JavaScript的可执行代码：全局代码、函数代码、eval代码  
当执行到一个函数的时候，就会创建一个执行上下文（Execution context），并且压入执行上下文栈（ECS）

**对于每个执行上下文，都会有三个重要属性**
- 变量对象（Variable object，VO）
- 作用域链 （Scope chain）
- this  

#### 变量对象  
变量对象是与执行上下文相关的数据作用域，存储在上下文中定义的变量和函数声明。

变量对象的创建过程
1. 全局上下文的变量对象初始化是全局对象
2. 函数上下文的变量对象初始化只包括Arguments对象
3. 在进入执行上下文时会给变量对象添加形参、函数声明、变量声明等初始的属性
4. 在代码进入阶段，会再次修改变量对象的属性值

#### 作用域链  
函数有一个内部属性`[[scope]]`，当函数创建的时候，就会保存所有父变量对象到其中。  
函数激活：当函数激活时，进入函数上下文，创建VO/AO后，将活动对象添加到作用域链的前端。这时候执行上下文的作用域链，命名为Scope
#### **ECMAScript规范解读this**
#### 执行上下文
#### 闭包
#### 参数按值传递
#### **call和applu模拟实现**
#### bind的模拟实现
#### **new模拟实现**
#### 数组对象与arguments
#### 创建对象多种方式及优缺点
#### 继承多种方式及优缺点
#### 防抖
#### 节流
#### 数组去重
#### 类型判断
#### 深浅拷贝
#### 从零实现jQuery的extend
#### 数组最大值和最小值
#### 数组扁平化
#### 在数组中查找指定元素
#### jQuery通用遍历方法each的实现
#### 判断两个对象相等
#### 函数柯里化
#### 偏函数
#### 惰性函数
#### 函数组合
#### 函数记忆
#### 递归
#### 乱序
#### 解读v8排序源码
